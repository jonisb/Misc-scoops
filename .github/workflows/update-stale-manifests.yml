name: Update Stale Manifests

on:
  workflow_dispatch:
    inputs:
      apps:
        description: 'Space-separated list of manifests to refresh (e.g. "indiegala-gog")'
        required: true
        default: indiegala-gog

permissions:
  contents: write

concurrency:
  group: update-manifests
  cancel-in-progress: false

jobs:
  update:
    runs-on: windows-latest
    timeout-minutes: 30
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Scoop
        shell: powershell
        run: |
          Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope Process -Force
          $installerUrl = 'https://raw.githubusercontent.com/ScoopInstaller/Install/ff4eedda58d832b8225d7697510f097ebe8ab071/install.ps1'
          $expectedHash = 'ef65c5a3d9f224d7c69a0e5d43008291f677e60c2f7898b132edbca4aaff021c'
          # Hash verified on 2025-12-13. Update expectedHash if the installer script is revised.
          $scoopInstaller = Join-Path $env:TEMP 'install-scoop.ps1'

          irm -Uri $installerUrl -OutFile $scoopInstaller -TimeoutSec 60 -ErrorAction Stop
          $installerHash = (Get-FileHash $scoopInstaller -Algorithm SHA256).Hash.ToLower()
          if ($installerHash -ne $expectedHash) {
              throw "Unexpected installer hash: $installerHash"
          }

          & $scoopInstaller
          "$env:USERPROFILE\scoop\shims" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

          # Create cache directory if it doesn't exist (required for some workflows)
          $cachePath = Join-Path $env:USERPROFILE "scoop\cache"
          if (-not (Test-Path $cachePath)) {
            New-Item -ItemType Directory -Path $cachePath -Force | Out-Null
            Write-Output "Created Scoop cache directory at: $cachePath"
          }

      - name: Add bucket
        shell: powershell
        run: |
          $bucketDir = "$env:USERPROFILE\scoop\buckets\misc-scoops"
          if (Test-Path $bucketDir) {
              Remove-Item $bucketDir -Force -Recurse
          }
          New-Item -ItemType Junction -Path $bucketDir -Target $env:GITHUB_WORKSPACE | Out-Null

      - name: Refresh hashes
        shell: powershell
        run: |
          $apps = "${{ github.event.inputs.apps }}".Split(' ', [System.StringSplitOptions]::RemoveEmptyEntries)
          if ($apps | Where-Object { $_ -notmatch '^[A-Za-z][A-Za-z0-9.-]*$' }) {
              throw "Invalid app name provided."
          }
          if ($apps.Count -eq 0) {
              Write-Output "No apps specified. Skipping."
              exit 0
          }

          $bucketPath = $env:GITHUB_WORKSPACE
          $checkhashesScript = "$env:USERPROFILE\scoop\apps\scoop\current\bin\checkhashes.ps1"
          $jsonDepth = 20

          if (-not (Test-Path $checkhashesScript)) {
              throw "checkhashes script not found at $checkhashesScript"
          }

          # Change to repository root directory for checkhashes to work
          Set-Location $env:GITHUB_WORKSPACE

          foreach ($app in $apps) {
              Write-Output "`n=========================================="
              Write-Output "Updating: $app"
              Write-Output "=========================================="
              
              # Get manifest path and hash before running checkhashes
              $manifestPath = Join-Path $bucketPath "bucket\$app.json"
              if (-not (Test-Path $manifestPath)) {
                  throw "Manifest not found: $manifestPath"
              }
              $hashBefore = (Get-FileHash $manifestPath).Hash
              
              # Run checkhashes and capture all output
              # Note: Using 2>&1 | Out-String to merge stderr/stdout and convert to string for pattern matching
              $output = & $checkhashesScript -App $app -Dir $bucketPath -Update 2>&1 | Out-String
              $lastExitCode = $LASTEXITCODE
              
              # Get manifest hash after running checkhashes
              $hashAfter = (Get-FileHash $manifestPath).Hash
              $manifestChanged = $hashBefore -ne $hashAfter
              
              # Check for error patterns in output (with word boundaries to avoid false positives)
              $hasError = $output -match "(?i)\b(error|exception|could not|failed|unable to|timeout)\b"
              $hasOkOutput = $output -match "(?i)\bOK\b"
              
              # Determine exit code handling
              if ($null -eq $lastExitCode) {
                  # PowerShell script didn't set LASTEXITCODE (common with PowerShell scripts called via &)
                  # Use output analysis and manifest changes to determine success/failure
                  if ($hasError) {
                      Write-Warning "checkhashes returned no exit code, but output indicates an error"
                      $exitCode = 1
                  } elseif ($manifestChanged -or $hasOkOutput) {
                      Write-Output "checkhashes returned no exit code; manifest was updated or verified successfully"
                      $exitCode = 0
                  } else {
                      # No clear error, no manifest changes, no explicit OK
                      # This typically means the script ran but found nothing to do (e.g., manifest already up to date)
                      # Since we use -Update flag, lack of changes with no errors indicates success
                      Write-Warning "checkhashes returned no exit code and no clear status; treating as success (verify logs)"
                      $exitCode = 0
                  }
              } else {
                  $exitCode = [int] $lastExitCode
              }
              
              Write-Output "checkhashes exit code: $exitCode"
              Write-Output "Manifest changed: $manifestChanged"
              Write-Output $output.Trim()

              # Add note if hashes were verified but unchanged
              $hashVerifiedWithoutChanges = -not $manifestChanged -and $hasOkOutput -and -not $hasError
              if ($hashVerifiedWithoutChanges) {
                  $note = "Updated $(Get-Date -Format 'yyyy-MM-dd'): manifest refreshed; hashes unchanged"
                  try {
                      $manifestJson = Get-Content -Path $manifestPath -Raw | ConvertFrom-Json
                      $combinedNotes = @()
                      if ($manifestJson.PSObject.Properties.Name -contains "freshness_notes") {
                          $existingNote = $manifestJson.freshness_notes
                          if ($existingNote -is [array]) {
                              foreach ($noteEntry in $existingNote) {
                                  if (-not [string]::IsNullOrWhiteSpace([string]$noteEntry)) {
                                      $combinedNotes += [string]$noteEntry
                                  }
                              }
                          } else {
                              if (-not [string]::IsNullOrWhiteSpace([string]$existingNote)) {
                                  $combinedNotes += [string]$existingNote
                              }
                          }
                      }
                      $combinedNotes += $note
                      $manifestJson.freshness_notes = $combinedNotes
                      $manifestJson | ConvertTo-Json -Depth $jsonDepth | Set-Content -Path $manifestPath -Encoding utf8
                      $manifestChanged = $true
                      Write-Output "Added note to manifest: hashes verified but unchanged"
                  } catch {
                      Write-Warning "Unable to add hash-unchanged note for ${app}: $_"
                  }
              }

              if ($exitCode -gt 0) {
                  throw "checkhashes failed for $app (exit code $exitCode)"
              }
          }

      - name: Commit changes
        shell: powershell
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          $apps = "${{ github.event.inputs.apps }}".Split(' ', [System.StringSplitOptions]::RemoveEmptyEntries)
          $commitMessage = "Refresh stale manifest(s)"
          if ($apps.Count -gt 0) {
              $commitMessage = "${commitMessage}: $($apps -join ', ')"
          }
          $commitMessage = "$commitMessage [skip ci]"

          $changes = git status --porcelain
          if (-not [string]::IsNullOrWhiteSpace($changes)) {
              git add .
              git commit -m "$commitMessage"
              git push
          } else {
              Write-Output "No manifest updates produced."
          }
