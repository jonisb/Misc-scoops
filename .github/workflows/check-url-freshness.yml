name: Check URL Freshness

on:
  schedule:
    - cron: '0 6 * * *' # Run daily at 6 AM UTC
  workflow_dispatch: # Allow manual triggering

permissions:
  contents: write

concurrency:
  group: update-manifests
  cancel-in-progress: false

jobs:
  check-url-freshness:
    name: Check URL Freshness
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      contents: read
    outputs:
      has_updates: ${{ steps.check.outputs.has_updates }}
      stale_apps: ${{ steps.check.outputs.stale_apps }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history needed to get manifest last commit dates

      - name: Check URL freshness
        id: check
        shell: bash
        run: |
          set -euo pipefail

          REPORT_FILE="/tmp/report.md"
          USER_AGENT="Mozilla/5.0 (compatible; ScoopBucketChecker/1.0; +https://github.com/${{ github.repository }})"

          # Initialize report
          {
            echo "# URL Freshness Report"
            echo ""
            echo "Generated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo ""
          } > "$REPORT_FILE"

          # Use arrays for safe string accumulation
          declare -a UPDATED_ITEMS=()
          declare -a FAILED_ITEMS=()
          declare -a WARNING_ITEMS=()
          declare -a STALE_APPS=()

          # Process each manifest file using nullglob to handle no matches gracefully
          shopt -s nullglob
          for manifest in bucket/*.json; do
            app_name=$(basename "$manifest" .json)

            # Get the last commit date for this manifest file (Unix timestamp)
            manifest_commit_timestamp=$(git log -1 --format="%ct" -- "$manifest" 2>/dev/null || echo "")
            if [ -z "$manifest_commit_timestamp" ]; then
              echo "Manifest: $app_name (WARNING: No git history found, skipping)"
              FAILED_ITEMS+=("- **${app_name}**: No git history found for manifest")
              continue
            fi
            manifest_commit_date=$(date -u -d "@$manifest_commit_timestamp" '+%a, %d %b %Y %H:%M:%S GMT')
            echo "Manifest: $app_name (last updated: $manifest_commit_date)"

            # Track if this app has any stale URLs
            app_is_stale=false

            # Extract URLs from the manifest using null delimiter for safe reading
            while IFS= read -r -d '' url; do
              if [ -z "$url" ] || [ "$url" = "null" ]; then
                continue
              fi

              # Remove fragment from URL (e.g., #/dl.exe) using bash parameter expansion
              clean_url="${url%%#*}"

              echo "  Checking URL: $clean_url"

              # Get Last-Modified header using HEAD request with user agent and limited redirects
              # Capture curl output and exit code, handling failures gracefully with set -e
              curl_exit_code=0
              response=$(curl -sI -L --max-redirs 5 --max-time 30 -A "$USER_AGENT" "$clean_url" 2>/dev/null) || curl_exit_code=$?
              last_modified=$(echo "$response" | grep -i "^last-modified:" | tail -1 | sed 's/^[Ll]ast-[Mm]odified: *//' | tr -d '\r' || true)

              if [ -z "$last_modified" ]; then
                if [ "$curl_exit_code" -ne 0 ]; then
                  echo "    Warning: Connection failed (curl exit code: $curl_exit_code)"
                  FAILED_ITEMS+=("- **${app_name}**: \`${clean_url}\` (Connection failed, curl exit code: $curl_exit_code)")
                else
                  echo "    Note: No Last-Modified header found, skipping freshness check"
                  WARNING_ITEMS+=("- **${app_name}**: \`${clean_url}\` (No Last-Modified header)")
                fi
                continue
              fi

              echo "    Last-Modified: $last_modified"

              # Convert Last-Modified header to Unix timestamp for comparison
              url_timestamp=$(date -u -d "$last_modified" '+%s' 2>/dev/null || echo "")
              if [ -z "$url_timestamp" ]; then
                echo "    Warning: Could not parse Last-Modified header"
                FAILED_ITEMS+=("- **${app_name}**: \`${clean_url}\` (Invalid Last-Modified format: ${last_modified})")
                continue
              fi

              if [ "$url_timestamp" -gt "$manifest_commit_timestamp" ]; then
                echo "    Status: UPDATED! URL modified after manifest was last updated"
                UPDATED_ITEMS+=("- **${app_name}**: \`${clean_url}\`" "  - Manifest last updated: ${manifest_commit_date}" "  - URL Last-Modified: ${last_modified}")
                app_is_stale=true
              else
                echo "    Status: OK (URL not modified since manifest update)"
              fi
            done < <(jq -j '
              [
                .url,
                .architecture?.["64bit"]?.url,
                .architecture?.["32bit"]?.url,
                .architecture?.arm64?.url
              ] | map(select(. != null)) | .[] | (. + "\u0000")
            ' "$manifest" 2>/dev/null || true)

            # Add to stale apps list if any URL was stale (avoid duplicates)
            if [ "$app_is_stale" = true ]; then
              STALE_APPS+=("$app_name")
            fi
          done
          shopt -u nullglob

          # Generate report
          if [ ${#UPDATED_ITEMS[@]} -gt 0 ]; then
            {
              echo "## ⚠️ URLs Updated Since Manifest Change"
              echo ""
              echo "The following URLs have been modified since their manifest was last updated:"
              echo ""
              printf '%s\n' "${UPDATED_ITEMS[@]}"
              echo ""
            } >> "$REPORT_FILE"
            echo "has_updates=true" >> "$GITHUB_OUTPUT"
            # Output the list of stale apps as a comma-separated string (safer than space for parsing)
            stale_apps_list=$(IFS=,; echo "${STALE_APPS[*]}")
            echo "stale_apps=$stale_apps_list" >> "$GITHUB_OUTPUT"
          else
            {
              echo "## ✅ No Updated URLs"
              echo ""
              echo "All URLs have not been modified since their manifest was last updated."
              echo ""
            } >> "$REPORT_FILE"
            echo "has_updates=false" >> "$GITHUB_OUTPUT"
            echo "stale_apps=" >> "$GITHUB_OUTPUT"
          fi

          if [ ${#WARNING_ITEMS[@]} -gt 0 ]; then
            {
              echo "## ⚠️ URLs With Warnings (Non-blocking)"
              echo ""
              echo "The following URLs could not be checked but this is not considered an error:"
              echo ""
              printf '%s\n' "${WARNING_ITEMS[@]}"
              echo ""
            } >> "$REPORT_FILE"
          fi

          if [ ${#FAILED_ITEMS[@]} -gt 0 ]; then
            {
              echo "## ❌ URLs With Issues"
              echo ""
              echo "The following URLs had issues during checking:"
              echo ""
              printf '%s\n' "${FAILED_ITEMS[@]}"
              echo ""
            } >> "$REPORT_FILE"
          fi

          # Output report to job summary
          cat "$REPORT_FILE" >> "$GITHUB_STEP_SUMMARY"

  update-manifests:
    name: Update Stale Manifests
    needs: check-url-freshness
    if: needs.check-url-freshness.outputs.has_updates == 'true'
    runs-on: windows-latest
    timeout-minutes: 30
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Scoop
        shell: powershell
        run: |
          Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope Process -Force
          $installerUrl = 'https://raw.githubusercontent.com/ScoopInstaller/Install/ff4eedda58d832b8225d7697510f097ebe8ab071/install.ps1'
          $expectedHash = 'ef65c5a3d9f224d7c69a0e5d43008291f677e60c2f7898b132edbca4aaff021c'
          # Hash verified on 2025-12-13. Update expectedHash if the installer script is revised.
          $scoopInstaller = Join-Path $env:TEMP 'install-scoop.ps1'

          irm -Uri $installerUrl -OutFile $scoopInstaller -TimeoutSec 60 -ErrorAction Stop
          $installerHash = (Get-FileHash $scoopInstaller -Algorithm SHA256).Hash.ToLower()
          if ($installerHash -ne $expectedHash) {
              throw "Unexpected installer hash: $installerHash"
          }

          & $scoopInstaller
          "$env:USERPROFILE\scoop\shims" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

          # Create cache directory if it doesn't exist
          $cachePath = Join-Path $env:USERPROFILE "scoop\cache"
          if (-not (Test-Path $cachePath)) {
            New-Item -ItemType Directory -Path $cachePath -Force | Out-Null
            Write-Output "Created Scoop cache directory at: $cachePath"
          }

      - name: Update stale manifests
        id: update
        shell: powershell
        run: |
          # Split on comma (matching the output format from check job)
          $staleApps = "${{ needs.check-url-freshness.outputs.stale_apps }}" -split ","
          Write-Output "Stale apps to update: $($staleApps -join ', ')"
          Write-Output ""

          # Change to repository root directory for checkhashes to work
          Set-Location $env:GITHUB_WORKSPACE

          # Get bucket path for manifest validation
          $bucketPath = Join-Path $env:GITHUB_WORKSPACE "bucket"
          $jsonDepth = 20

          $updatedApps = @()
          $skippedApps = @()
          $failedApps = @()

          foreach ($app in $staleApps) {
            $app = $app.Trim()
            if ([string]::IsNullOrWhiteSpace($app)) { continue }

            $manifestPath = Join-Path $bucketPath "$app.json"
            if (-not (Test-Path $manifestPath)) {
              Write-Output "Skipping $app - manifest not found"
              continue
            }

            Write-Output "=========================================="
            Write-Output "Updating: $app"
            Write-Output "=========================================="

            try {
              # Get manifest hash before checkhashes to detect changes
              $hashBefore = (Get-FileHash $manifestPath).Hash

              # Run checkhashes script directly (checkhashes is not a scoop command, it's a script)
              # The script is located at bin\checkhashes.ps1 in the Scoop installation
              # The -Update flag enables auto-update of the manifest hashes
              # The -Dir parameter specifies the bucket directory
              $checkhashesScript = Join-Path $env:USERPROFILE "scoop\apps\scoop\current\bin\checkhashes.ps1"
              if (-not (Test-Path $checkhashesScript)) {
                throw "checkhashes.ps1 script not found at: $checkhashesScript"
              }
              $output = & $checkhashesScript -App $app -Dir $env:GITHUB_WORKSPACE -Update 2>&1 | Out-String
              $lastExitCode = $LASTEXITCODE
              Write-Output $output.Trim()

              # Get manifest hash after checkhashes to detect changes
              $hashAfter = (Get-FileHash $manifestPath).Hash
              $manifestChanged = $hashBefore -ne $hashAfter

              # Match patterns indicating hash verification or errors
              $hasOkOutput = $output -match "(?i)\bOK\b"
              $hasError = $output -match "(?i)(error|exception|could not|failed|unable to|timeout)"
              
              # PowerShell scripts called with & may not set LASTEXITCODE
              # Determine exit code based on output analysis and manifest changes
              if ($null -eq $lastExitCode) {
                  # PowerShell script didn't set LASTEXITCODE (common with PowerShell scripts called via &)
                  # Use output analysis and manifest changes to determine success/failure
                  if ($hasError) {
                      Write-Warning "checkhashes returned no exit code, but output indicates an error"
                      $exitCode = 1
                  } elseif ($manifestChanged -or $hasOkOutput) {
                      Write-Output "checkhashes returned no exit code; manifest was updated or verified successfully"
                      $exitCode = 0
                  } else {
                      # No clear error, no manifest changes, no explicit OK
                      # This typically means the script ran but found nothing to do (e.g., manifest already up to date)
                      # Since we use -Update flag, lack of changes with no errors indicates success
                      Write-Warning "checkhashes returned no exit code and no clear status; treating as success (verify logs)"
                      $exitCode = 0
                  }
              } else {
                  $exitCode = [int] $lastExitCode
              }
              $hashVerifiedWithoutChanges = -not $manifestChanged -and $hasOkOutput -and -not $hasError

              if ($hashVerifiedWithoutChanges) {
                $note = "Updated $(Get-Date -Format 'yyyy-MM-dd'): manifest refreshed; hashes unchanged"
                try {
                  $manifestJson = Get-Content -Path $manifestPath -Raw | ConvertFrom-Json
                  $combinedNotes = @()
                  if ($manifestJson.PSObject.Properties.Name -contains "freshness_notes") {
                    $existingNote = $manifestJson.freshness_notes
                    if ($existingNote -is [array]) {
                      foreach ($noteEntry in $existingNote) {
                        if (-not [string]::IsNullOrWhiteSpace([string]$noteEntry)) {
                          $combinedNotes += [string]$noteEntry
                        }
                      }
                    } else {
                      if (-not [string]::IsNullOrWhiteSpace([string]$existingNote)) {
                        $combinedNotes += [string]$existingNote
                      }
                    }
                  }
                  $combinedNotes += $note
                  $manifestJson.freshness_notes = $combinedNotes
                  $manifestJson | ConvertTo-Json -Depth $jsonDepth | Set-Content -Path $manifestPath -Encoding utf8
                  $manifestChanged = $true
                  Write-Output "[OK] $app manifest refreshed with hash-unchanged note"
                } catch {
                  Write-Output "[WARN] Unable to add hash-unchanged note for $app : $_"
                }
              }

              if ($exitCode -gt 0 -and $hasError) {
                Write-Output "[FAIL] $app encountered an error during hash check"
                $failedApps += $app
              } elseif ($manifestChanged) {
                if ($hashVerifiedWithoutChanges) {
                  Write-Output "[OK] $app manifest updated (hashes unchanged)"
                } else {
                  Write-Output "[OK] $app manifest hashes were updated"
                }
                $updatedApps += $app
              } elseif ($hasOkOutput -and -not $hasError) {
                # checkhashes successfully verified hashes
                Write-Output "[OK] $app hashes are correct"
                $updatedApps += $app
              } else {
                # No clear success or error pattern - track as skipped
                Write-Output "[SKIP] ${app}: checkhashes completed without clear success/error indication"
                $skippedApps += $app
              }
            } catch {
              Write-Output "[FAIL] Failed to update $app : $_"
              $failedApps += $app
            }
            Write-Output ""
          }

          Write-Output "=========================================="
          Write-Output "Summary"
          Write-Output "=========================================="
          Write-Output "Updated apps: $($updatedApps -join ', ')"
          if ($skippedApps.Count -gt 0) {
            Write-Output "Skipped apps: $($skippedApps -join ', ')"
          }
          if ($failedApps.Count -gt 0) {
            Write-Output "Failed apps: $($failedApps -join ', ')"
          }

          # Write results to job summary
          "## Update Stale Manifests Results`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
          "**Generated:** $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss') UTC`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8

          if ($updatedApps.Count -gt 0) {
            "### ✅ Successfully Processed Apps`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
            foreach ($app in $updatedApps) {
              "- $app" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
            }
            "`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
          }

          if ($skippedApps.Count -gt 0) {
            "### ⚠️ Skipped Apps (checkhashes returned without clear status)`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
            foreach ($app in $skippedApps) {
              "- $app" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
            }
            "`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
          }

          if ($failedApps.Count -gt 0) {
            "### ❌ Failed Apps`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
            foreach ($app in $failedApps) {
              "- $app" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
            }
            "`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Append -Encoding utf8
            # Output failed apps for later step to fail the job after commit
            "failed_apps=$($failedApps -join ',')" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          }

      - name: Commit and push changes
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check if there are any changes to commit
          if git diff --quiet bucket/; then
            echo "No manifest changes detected"
            exit 0
          fi

          git add bucket/*.json
          git commit -m "Auto-update stale manifests [skip ci]"
          git push

      - name: Report failures
        if: steps.update.outputs.failed_apps != ''
        shell: bash
        run: |
          echo "::error::Failed to update the following apps: ${{ steps.update.outputs.failed_apps }}"
          exit 1
